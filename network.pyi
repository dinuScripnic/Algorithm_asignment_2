from __future__ import annotations

from typing import MutableSequence, Generic
from protocols import ID
from messaging import Message
from registry import Registry
from person import Person

class InvalidNetworkException(Exception): ...
class PriorityQueue(Generic[ID]):
    def __init__(self) -> None: ...
    def add(self, message: Message) -> None: ...
    def remove_for_person(self, person_id: ID) ->None: ...
    def remove_message(self, message: Message) -> None: ...
    def return_all_messages_of_a_person(self, person_id: ID) -> MutableSequence[Message]: ...
    def __len__(self) -> int: ...
    

class Node(Generic[ID]):
    node_id: ID
    
    def __init__(self, node_id: ID) -> None: ...
    def receive(self, message: Message) -> None: ...
    def get_all_messages(self, person: ID) -> MutableSequence[Message]: ...
    def delete_messages(self, person: ID) -> None: ...
    def delete_for_forwarding(self, message: Message) -> None: ...
    def delete_all_messages(self) -> None: ...

class LinkedList(Generic[ID]):
    def __init__(self) -> None: ...
    def insert(self, node: Node) -> None: ...
    def search(self, node_id: ID) -> Node | None: ...
    def delete(self, node_id: ID) -> None: ...
    def exists(self, node_id: ID) -> bool: ...
    def get(self, index: int) -> Node: ...
    def __iter__(self) -> LinkedList: ...
    def __len__(self) -> int: ...

class Edge(Generic[ID]):
    def __init__(self, node1: ID, node2: ID) -> None: ...
    def __eq__(self, other: Edge) -> bool: ...
    

class CommunicationNetwork(Generic[ID]):
    _registry: Registry
    _nodes: list
    _edges: list
    def __init__(self) -> None: ...
    def add(self, node: Node[ID]) -> None: ...
    def add_multiple(self, nodes: list[Node]) -> None: ...
    def remove(self, node: Node[ID]) -> None: ...
    def link(self, node_1: Node[ID], node_2: Node[ID], cost: int) -> None: ...
    def unlink(self, node_1: Node[ID], node_2: Node[ID]) -> None: ...
    def is_valid(self) -> bool: ...
    def _dfs(self, node: Node[ID], visited: set[Node[ID]]) -> None: ...
    def minimum_distance(self, distances: dict[Node[ID], int], visited: set[Node[ID]]) -> Node[ID]: ...
    def dijkstra(self, start_node: Node[ID]) -> list[dict, dict]: ...
    def path(self, end_node: Node[ID], prev: dict) -> list[Node[ID]]: ...
    def broadcast(self, message: Message) -> None: ...
    def send(self, message: Message) -> None: ...
    def forward(self, message: Message, node: Node[ID]) -> None: ...
    def join_network(self, person: Person, node_id: ID) -> None: ...
    def leave_network(self, person: Person) -> None: ...
    def get_all_messages(self, person: Person) -> MutableSequence[Message]: ...
